/* THIS FILE IS AUTOMATICALLY GENERATED AND MUST NOT BE EDITED MANUALLY */

import { TypeExpression } from '@io-maana/typesystem-utils';

/* Run `npm run generate` in maana-portal to regenerate these types. */
export type Maybe<T> = T | null;
export type Exact<T extends { [key: string]: unknown }> = {
  [K in keyof T]: T[K];
};
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  DateTime: string;
  TypeExpression: TypeExpression;
  Date: string;
  Time: string;
  JSON: string;
  EntityIdentifier: any;
  Locator: any;
};

/** Activity type - gives the ability to have activities on the home page */
export type Activity = {
  __typename: 'Activity';
  /** ID of the activity */
  id: Scalars['ID'];
  /** Name of the activity */
  name: Scalars['String'];
  /** Content of the activity */
  detail?: Maybe<Scalars['String']>;
  /** Author of the activity */
  author: User;
  /** Date/time the activity was made */
  timestamp: Scalars['DateTime'];
};

export type AddBotActionInput = {
  name?: Maybe<Scalars['String']>;
  serviceId?: Maybe<Scalars['ID']>;
  serviceName?: Maybe<Scalars['String']>;
  botId?: Maybe<Scalars['ID']>;
  kindId?: Maybe<Scalars['ID']>;
  eventName?: Maybe<Scalars['String']>;
  mutationName?: Maybe<Scalars['String']>;
  queryName?: Maybe<Scalars['String']>;
  inputInstanceRef?: Maybe<InstanceRefInput>;
  outputInstanceRef?: Maybe<InstanceRefInput>;
};

export type AddDocumentInput = {
  id?: Maybe<Scalars['ID']>;
  name?: Maybe<Scalars['String']>;
  text?: Maybe<Scalars['String']>;
  xhtml?: Maybe<Scalars['String']>;
  pages?: Maybe<Array<Maybe<Scalars['ID']>>>;
  sections?: Maybe<Array<Maybe<Scalars['ID']>>>;
  content?: Maybe<Array<Maybe<Scalars['ID']>>>;
};

export type AddEntitiesInput = {
  docId: Scalars['ID'];
  entities: Array<EntityInput>;
};

export type AddImageInput = {
  id?: Maybe<Scalars['ID']>;
  name?: Maybe<Scalars['String']>;
  url?: Maybe<Scalars['String']>;
};

export type AddInstanceInput = {
  kindId: Scalars['ID'];
  id?: Maybe<Scalars['ID']>;
  fieldIds: Array<Maybe<Scalars['ID']>>;
  fieldValues: Array<Maybe<FieldValueInput>>;
};

export type AddInstanceSetInput = {
  kindId: Scalars['ID'];
  ids?: Maybe<Array<Maybe<Scalars['ID']>>>;
  fieldIds: Array<Maybe<Scalars['ID']>>;
  records: Array<Maybe<Array<Maybe<FieldValueInput>>>>;
};

export type AddKindInput = {
  id?: Maybe<Scalars['ID']>;
  name: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  serviceId: Scalars['ID'];
  thumbnailUrl?: Maybe<Scalars['String']>;
  isPublic?: Maybe<Scalars['Boolean']>;
  nameField?: Maybe<Scalars['ID']>;
  isManaged?: Maybe<Scalars['Boolean']>;
  isSystem?: Maybe<Scalars['Boolean']>;
  schema?: Maybe<Array<FieldInput>>;
};

export type AddLinkInput = {
  fromKindId?: Maybe<Scalars['ID']>;
  fromKindName?: Maybe<Scalars['String']>;
  toKindId?: Maybe<Scalars['ID']>;
  toKindName?: Maybe<Scalars['String']>;
  relationId?: Maybe<Scalars['ID']>;
  relationName?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['ID']>;
  name?: Maybe<Scalars['String']>;
  weight?: Maybe<Scalars['Float']>;
  fromFieldId?: Maybe<Scalars['ID']>;
  fromFieldName?: Maybe<Scalars['String']>;
  fromInstanceId?: Maybe<Scalars['ID']>;
  fromOffset?: Maybe<Scalars['String']>;
  fromSpan?: Maybe<Scalars['String']>;
  toFieldId?: Maybe<Scalars['ID']>;
  toFieldName?: Maybe<Scalars['String']>;
  toInstanceId?: Maybe<Scalars['ID']>;
  toOffset?: Maybe<Scalars['String']>;
  toSpan?: Maybe<Scalars['String']>;
};

export type AddRelationInput = {
  name: Scalars['String'];
  id?: Maybe<Scalars['ID']>;
  inverseName: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  undirected?: Maybe<Scalars['Boolean']>;
  weight?: Maybe<Scalars['Float']>;
};

export type AddServiceSourceInput = {
  id?: Maybe<Scalars['ID']>;
  name?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  schema: Scalars['String'];
};

export const enum AggregateOp {
  MIN = 'MIN',
  MAX = 'MAX',
  SUM = 'SUM',
  COUNT = 'COUNT'
}

/**
 * AllReferencedServices input - The input information for the all references
 * services query.
 */
export type AllReferencedServicesInput = {
  entities: Array<Scalars['EntityIdentifier']>;
  entitiesToSkip?: Maybe<Array<Scalars['EntityIdentifier']>>;
  maxDepth?: Scalars['Int'];
};

export type Annotation = EntityInterface & {
  __typename: 'Annotation';
  id: Scalars['ID'];
  name: Scalars['String'];
  nameDescriptor?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  /** The workspace that contains the annotation */
  workspace?: Maybe<Workspace>;
};

export type ArgumentFieldSelection = {
  __typename: 'ArgumentFieldSelection';
  argument: Scalars['ID'];
  fieldSelection?: Maybe<Array<Array<Scalars['ID']>>>;
};

export type ArgumentFieldSelectionInput = {
  argument: Scalars['ID'];
  fieldSelection?: Maybe<Array<Array<Scalars['ID']>>>;
};

export type ArgumentNode = Node & {
  __typename: 'ArgumentNode';
  id: Scalars['ID'];
  description?: Maybe<Scalars['String']>;
  location?: Maybe<Position>;
  isCollapsed: Array<Scalars['String']>;
};

export type ArgumentRef = {
  __typename: 'ArgumentRef';
  argumentName: Scalars['String'];
  argumentId: Scalars['ID'];
};

/** AssistantService type - Based on the one from Catalog */
export type AssistantService = Service & {
  __typename: 'AssistantService';
  id: Scalars['ID'];
  name: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  location: ServiceLocation;
  thumbnailUrl?: Maybe<Scalars['String']>;
  tags: Array<Scalars['String']>;
  version?: Maybe<Scalars['Int']>;
};

/** Attachment Input - information about attachments added to user feedback. */
export type AttachmentInput = {
  /** The name of the file attached. */
  filename: Scalars['String'];
  /** The type of file that is being attached. (jpg, png, gif, etc...) */
  contentType: Scalars['String'];
  /** The contexts of the file in a base64 string. */
  content: Scalars['String'];
};

export type Bot = {
  __typename: 'Bot';
  id: Scalars['ID'];
  name: Scalars['String'];
  service?: Maybe<Service>;
};

export type BotAction = {
  __typename: 'BotAction';
  id: Scalars['ID'];
  name: Scalars['String'];
  created: Scalars['DateTime'];
  lastUpdated: Scalars['DateTime'];
  status: BotActionStatus;
  progress?: Maybe<Scalars['Float']>;
  errors?: Maybe<Array<Scalars['JSON']>>;
  bot?: Maybe<Bot>;
  kind?: Maybe<Kind>;
  service: Service;
  eventName?: Maybe<Scalars['String']>;
  function?: Maybe<Function>;
  input?: Maybe<InstanceRef>;
  output?: Maybe<InstanceRef>;
};

export type BotActionAddedEvent = {
  __typename: 'BotActionAddedEvent';
  id: Scalars['ID'];
  name: Scalars['String'];
  serviceName: Scalars['String'];
  serviceId?: Maybe<Scalars['ID']>;
  bot?: Maybe<Bot>;
  kind?: Maybe<Kind>;
  eventName?: Maybe<Scalars['String']>;
  mutationName?: Maybe<Scalars['String']>;
  queryName?: Maybe<Scalars['String']>;
  inputInstanceRef?: Maybe<InstanceRef>;
  outputInstanceRef?: Maybe<InstanceRef>;
};

export const enum BotActionStatus {
  PENDING = 'PENDING',
  IN_PROGRESS = 'IN_PROGRESS',
  STOPPING = 'STOPPING',
  STOPPED = 'STOPPED',
  ERROR = 'ERROR',
  COMPLETE = 'COMPLETE'
}

export type BotActionUpdatedEvent = {
  __typename: 'BotActionUpdatedEvent';
  id: Scalars['ID'];
  bot?: Maybe<Bot>;
  service?: Maybe<Service>;
  kind?: Maybe<Kind>;
  oldStatus: BotActionStatus;
  newStatus: BotActionStatus;
  progress?: Maybe<Scalars['Float']>;
  errors?: Maybe<Array<Scalars['JSON']>>;
};

/**
 * Clone Entity input - A generic input for cloning an entity.  Only works for
 * Types and Functions currently.
 */
export type CloneEntityInput = {
  entityType: EntityType;
  oldName: Scalars['String'];
  oldServiceId: Scalars['String'];
  newName: Scalars['String'];
};

export type CloneWorkspaceInput = {
  oldId: Scalars['ID'];
  newId?: Maybe<Scalars['ID']>;
  newServiceId?: Maybe<Scalars['ID']>;
  newOwner: Scalars['ID'];
  newName?: Maybe<Scalars['String']>;
};

/** Connection type - the connection between two items on a graph. */
export type Connection = {
  __typename: 'Connection';
  id: Scalars['ID'];
  /** End point for the outgoing connection point */
  from: GraphRef;
  /** End point for the incoming connection point */
  to: GraphRef;
};

export type Content = {
  __typename: 'Content';
  id: Scalars['ID'];
  table?: Maybe<Table>;
  unorderedList?: Maybe<UnorderedList>;
  orderedList?: Maybe<OrderedList>;
  text?: Maybe<Scalars['String']>;
  image?: Maybe<Image>;
};

/** CreateAnnotation input - used to create new annotations */
export type CreateAnnotationInput = {
  id?: Maybe<Scalars['ID']>;
  name: Scalars['String'];
  description?: Maybe<Scalars['String']>;
};

/** CreateAssistantInput input - Based on the one from Catalog */
export type CreateAssistantInput = {
  id?: Maybe<Scalars['ID']>;
  name: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  endpointUrl: Scalars['String'];
  thumbnailUrl?: Maybe<Scalars['String']>;
  isSystem?: Scalars['Boolean'];
  isReadOnly?: Scalars['Boolean'];
  tags?: Array<Scalars['String']>;
};

/** CreateConnection input - info needed to create a connection. */
export type CreateConnectionInput = {
  from: GraphRefInput;
  to: GraphRefInput;
};

/** CreateEntity input - A generic input for creating an entity. */
export type CreateEntityInput = {
  entityType: EntityType;
  knowledgeGraph?: Maybe<CreateKnowledgeGraphInput>;
  type?: Maybe<CreateTypeInput>;
  function?: Maybe<CreateFunctionInput>;
  file?: Maybe<CreateFileInput>;
  annotation?: Maybe<CreateAnnotationInput>;
};

/** CreateExternalGraphQLServiceInput input - Based on the one from Catalog */
export type CreateExternalGraphQLServiceInput = {
  id?: Maybe<Scalars['ID']>;
  name: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  endpointUrl: Scalars['String'];
  thumbnailUrl?: Maybe<Scalars['String']>;
  isSystem?: Scalars['Boolean'];
  isReadOnly?: Scalars['Boolean'];
  tags?: Array<Scalars['String']>;
};

/** CreateFile input - used to create new files */
export type CreateFileInput = {
  id?: Maybe<Scalars['ID']>;
  name?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  serviceId: Scalars['String'];
  url: Scalars['String'];
  thumbnailUrl?: Maybe<Scalars['String']>;
  mimeType?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['Int']>;
  progress?: Maybe<Scalars['Int']>;
  status?: Maybe<Scalars['Int']>;
  /**
   * When set to true and an external url is supplied, then createFiles will
   * introspect the file for information about its metadata.
   */
  loadExternalMetadata?: Maybe<Scalars['Boolean']>;
};

/** CreateFunction input - info needed to create a new Function */
export type CreateFunctionInput = {
  id?: Maybe<Scalars['ID']>;
  name: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  signature: Scalars['TypeExpression'];
  isPure?: Maybe<Scalars['Boolean']>;
  graphqlFunctionType: GraphQLFunctionType;
  implementation: ImplementationTypeInput;
  /**
   * Setup the implementation for CKG functions at the same time as creating the
   * function
   */
  graphImplementation?: Maybe<CreateGraphInput>;
  inputMask?: Maybe<Array<ArgumentFieldSelectionInput>>;
};

/**
 * CreateGraph input = allows for creating the graph when the knowledge graph or
 * function are created.
 */
export type CreateGraphInput = {
  offset?: Maybe<PositionInput>;
  zoom?: Maybe<Scalars['Float']>;
  nodes?: Maybe<Array<CreateNodeInput>>;
  connections?: Maybe<Array<CreateConnectionInput>>;
};

/** CreateKnowledgeGraph input - used to create new knowledge graphs */
export type CreateKnowledgeGraphInput = {
  id?: Maybe<Scalars['ID']>;
  name: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  graph?: Maybe<CreateGraphInput>;
};

/** CreateNode input - info needed for creating a new graph node */
export type CreateNodeInput = {
  id?: Maybe<Scalars['ID']>;
  location?: Maybe<PositionInput>;
  isCollapsed?: Maybe<Array<Scalars['String']>>;
  description?: Maybe<Scalars['String']>;
  /** The type of node being created */
  type: NodeType;
  /** Entity nodes point to a specific entity on a knowledge graph */
  entity?: Maybe<Scalars['EntityIdentifier']>;
  /** Operation nodes point to a specific function on a function graph */
  operation?: Maybe<Scalars['EntityIdentifier']>;
};

export type CreateTypeInput = {
  /**
   * Identifier to help reference the Type during the creation process.  The final
   * ID for the Type will be different.
   */
  id?: Maybe<Scalars['ID']>;
  name: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  signature: Scalars['TypeExpression'];
  isManaged?: Scalars['Boolean'];
};

/** CreateUser input - used to create a new User */
export type CreateUserInput = {
  email: Scalars['String'];
  name: Scalars['String'];
  givenName?: Maybe<Scalars['String']>;
  familyName?: Maybe<Scalars['String']>;
  picture?: Maybe<Scalars['String']>;
  theme: Theme;
};

export type CreateWorkspaceFromSchemaInput = {
  id?: Maybe<Scalars['ID']>;
  serviceId?: Maybe<Scalars['ID']>;
  name: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  thumbnailUrl?: Maybe<Scalars['String']>;
  tags?: Maybe<Array<Scalars['String']>>;
  owner: Scalars['ID'];
  isPublic?: Maybe<Scalars['Boolean']>;
  isTemplate?: Maybe<Scalars['Boolean']>;
  schema: Scalars['String'];
};

/** CreateWorkspace input - used to create new workspaces */
export type CreateWorkspaceInput = {
  id?: Maybe<Scalars['ID']>;
  serviceId?: Maybe<Scalars['ID']>;
  name: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  thumbnailUrl?: Maybe<Scalars['String']>;
  tags?: Maybe<Array<Scalars['String']>>;
  owner: Scalars['ID'];
  isPublic?: Maybe<Scalars['Boolean']>;
  isTemplate?: Maybe<Scalars['Boolean']>;
  createEntities?: Maybe<Array<CreateEntityInput>>;
  addServices?: Maybe<Array<Scalars['ID']>>;
  /**
   * Moves the given entities from their current Workspace to this one.  Currently
   * only Types and Functions support being moved between Workspaces.
   */
  moveEntities?: Maybe<Array<Scalars['EntityIdentifier']>>;
};

export type DeleteEntitiesOutput = {
  __typename: 'DeleteEntitiesOutput';
  updatedUsers: Array<User>;
  updatedKnowledgeGraphs: Array<KnowledgeGraph>;
  updatedWorkspaces: Array<Workspace>;
  updatedFunctions: Array<Function>;
  deletedGraphNodes: Array<Scalars['ID']>;
  deletedWorkspaces: Array<Scalars['ID']>;
  deletedServices: Array<Scalars['ID']>;
  deletedKnowledgeGraphs: Array<Scalars['ID']>;
  deletedFunctions: Array<Scalars['ID']>;
  deletedTypes: Array<Scalars['ID']>;
  deletedFiles: Array<Scalars['ID']>;
  deletedAnnotations: Array<Scalars['ID']>;
};

export type DeleteInstanceInput = {
  kindId: Scalars['ID'];
  id: Scalars['ID'];
};

export type DeleteInstanceSetInput = {
  kindId: Scalars['ID'];
  ids: Array<Scalars['ID']>;
};

export type DetectedFace = {
  __typename: 'DetectedFace';
  id: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
  image: Image;
  area: Scalars['Int'];
  bottom: Scalars['Int'];
  top: Scalars['Int'];
  right: Scalars['Int'];
  left: Scalars['Int'];
  detectionConfidence: Scalars['Float'];
};

export type DetectedFaceInput = {
  id?: Maybe<Scalars['ID']>;
  name?: Maybe<Scalars['String']>;
  imageId: Scalars['ID'];
  area: Scalars['Int'];
  bottom: Scalars['Int'];
  top: Scalars['Int'];
  right: Scalars['Int'];
  left: Scalars['Int'];
  detectionConfidence: Scalars['Float'];
};

export type Document = {
  __typename: 'Document';
  id: Scalars['ID'];
  name: Scalars['String'];
  text?: Maybe<Scalars['String']>;
  xhtml?: Maybe<Scalars['String']>;
  pages?: Maybe<Array<Maybe<Page>>>;
  sections?: Maybe<Array<Maybe<Section>>>;
  content?: Maybe<Array<Maybe<Content>>>;
};

export type Entity = {
  __typename: 'Entity';
  id: Scalars['ID'];
  name: Scalars['String'];
  class: Scalars['String'];
  count?: Maybe<Scalars['Int']>;
  percent?: Maybe<Scalars['Float']>;
};

/**
 * EntityAttribute enum - the different attributes that can be added to entities.
 * This is inferred and not editable.
 */
export const enum EntityAttribute {
  /** Indicates this is an automatically generated Entity. */
  GENERATED = 'GENERATED'
}

export type EntityInput = {
  id?: Maybe<Scalars['ID']>;
  name?: Maybe<Scalars['String']>;
  class?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['Int']>;
  percent?: Maybe<Scalars['Float']>;
};

/**
 * Entity interface - used to represent entities in a generic way. Used for places
 * where something needs to handle multiple different types, like the nodes on a
 * graph.
 */
export interface EntityInterface {
  /** ID of the entity. */
  id: Scalars['ID'];
  /** Name of the entity. */
  name: Scalars['String'];
  /**
   * Descriptor to help give context to the name. Usually, this is the name of the
   * entity's native workspace or service. This is inferred and not editable.
   */
  nameDescriptor?: Maybe<Scalars['String']>;
  /** Human readable description of the entity. */
  description?: Maybe<Scalars['String']>;
}

/** EntityLock type - Defines the information about a lock on a specific entity. */
export type EntityLock = {
  __typename: 'EntityLock';
  /** The user who locked the entity. */
  lockedBy: User;
};

/** EntityLock input - Defines the information an entity lock that is being created. */
export type EntityLockInput = {
  /** The e-mail of the user who locked the entity. */
  lockedBy: Scalars['String'];
};

export type EntityNode = Node & {
  __typename: 'EntityNode';
  id: Scalars['ID'];
  description?: Maybe<Scalars['String']>;
  location?: Maybe<Position>;
  isCollapsed: Array<Scalars['String']>;
  /** The ID and type of the entity displayed inside the node. */
  entityIdentifier: Scalars['EntityIdentifier'];
};

export type EntityOccurrences = {
  __typename: 'EntityOccurrences';
  kindId: Scalars['ID'];
  instanceId?: Maybe<Array<Scalars['ID']>>;
  locations: Array<Scalars['Int']>;
};

export type EntitySearchActionResult = {
  __typename: 'EntitySearchActionResult';
  results?: Maybe<Array<EntitySearchResult>>;
  token?: Maybe<Scalars['String']>;
};

export type EntitySearchInput = {
  entitySurfaceForms: Array<EntitySurfaceFormsInput>;
  scopeKindId: Scalars['ID'];
  scopeFieldId: Scalars['ID'];
  scopeInstanceId?: Maybe<Array<Scalars['ID']>>;
};

export type EntitySearchResult = {
  __typename: 'EntitySearchResult';
  scopeKindId: Scalars['ID'];
  scopeFieldId: Scalars['ID'];
  scopeInstanceId: Scalars['ID'];
  cooccurrences: Array<EntityOccurrences>;
};

export type EntitySurfaceFormsInput = {
  kindId: Scalars['ID'];
  instanceId?: Maybe<Array<Scalars['ID']>>;
  surfaceForms?: Maybe<Array<Scalars['String']>>;
};

/** EntityType enum - known entity types */
export const enum EntityType {
  WORKSPACE = 'WORKSPACE',
  SERVICE = 'SERVICE',
  KNOWLEDGE_GRAPH = 'KNOWLEDGE_GRAPH',
  TYPE = 'TYPE',
  FUNCTION = 'FUNCTION',
  FILE = 'FILE',
  ANNOTATION = 'ANNOTATION'
}

/** ExternalGraphQLService type - Based on the one from Catalog */
export type ExternalGraphQLService = Service & {
  __typename: 'ExternalGraphQLService';
  id: Scalars['ID'];
  name: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  location: ServiceLocation;
  thumbnailUrl?: Maybe<Scalars['String']>;
  tags: Array<Scalars['String']>;
  version?: Maybe<Scalars['Int']>;
  graphqlSchema: Scalars['String'];
  functions: Array<Function>;
  types: Array<Type>;
};

export type Field = {
  __typename: 'Field';
  id: Scalars['ID'];
  name: Scalars['String'];
  type: FieldType;
  description?: Maybe<Scalars['String']>;
  modifiers?: Maybe<Array<Maybe<FieldModifiers>>>;
  typeKindId?: Maybe<Scalars['ID']>;
  displayAs?: Maybe<Array<Maybe<Scalars['String']>>>;
  hide?: Maybe<Scalars['Boolean']>;
  autoFocus?: Maybe<Scalars['Boolean']>;
  readonly?: Maybe<Scalars['Boolean']>;
  kind?: Maybe<Kind>;
  isDeleted: Scalars['Boolean'];
};

export type FieldFilterInput = {
  fieldId?: Maybe<Scalars['ID']>;
  fieldName?: Maybe<Scalars['String']>;
  op: Scalars['String'];
  value: FieldValueInput;
};

export type FieldInput = {
  id?: Maybe<Scalars['ID']>;
  name: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  type: FieldType;
  typeKindId?: Maybe<Scalars['ID']>;
  modifiers?: Maybe<Array<FieldModifiers>>;
  displayAs?: Maybe<Array<Scalars['String']>>;
  hide?: Maybe<Scalars['Boolean']>;
  autoFocus?: Maybe<Scalars['Boolean']>;
  readonly?: Maybe<Scalars['Boolean']>;
};

export const enum FieldModifiers {
  NONULL = 'NONULL',
  LIST = 'LIST',
  NOIDX = 'NOIDX',
  EPHEMERAL = 'EPHEMERAL',
  IMIDX = 'IMIDX'
}

export type FieldProjectionInput = {
  fieldId?: Maybe<Scalars['ID']>;
  fieldName?: Maybe<Scalars['String']>;
  alias?: Maybe<Scalars['String']>;
  op?: Maybe<AggregateOp>;
};

export const enum FieldType {
  ID = 'ID',
  STRING = 'STRING',
  INT = 'INT',
  FLOAT = 'FLOAT',
  BOOLEAN = 'BOOLEAN',
  DATE = 'DATE',
  TIME = 'TIME',
  DATETIME = 'DATETIME',
  JSON = 'JSON',
  KIND = 'KIND'
}

export type FieldValue = {
  __typename: 'FieldValue';
  ID?: Maybe<Scalars['ID']>;
  STRING?: Maybe<Scalars['String']>;
  INT?: Maybe<Scalars['Int']>;
  FLOAT?: Maybe<Scalars['Float']>;
  BOOLEAN?: Maybe<Scalars['Boolean']>;
  DATE?: Maybe<Scalars['Date']>;
  TIME?: Maybe<Scalars['Time']>;
  DATETIME?: Maybe<Scalars['DateTime']>;
  JSON?: Maybe<Scalars['JSON']>;
  KIND?: Maybe<Scalars['ID']>;
  l_ID?: Maybe<Array<Maybe<Scalars['ID']>>>;
  l_STRING?: Maybe<Array<Maybe<Scalars['String']>>>;
  l_INT?: Maybe<Array<Maybe<Scalars['Int']>>>;
  l_FLOAT?: Maybe<Array<Maybe<Scalars['Float']>>>;
  l_BOOLEAN?: Maybe<Array<Maybe<Scalars['Boolean']>>>;
  l_DATE?: Maybe<Array<Maybe<Scalars['Date']>>>;
  l_TIME?: Maybe<Array<Maybe<Scalars['Time']>>>;
  l_DATETIME?: Maybe<Array<Maybe<Scalars['DateTime']>>>;
  l_JSON?: Maybe<Array<Maybe<Scalars['JSON']>>>;
  l_KIND?: Maybe<Array<Maybe<Scalars['ID']>>>;
};

export type FieldValueInput = {
  ID?: Maybe<Scalars['ID']>;
  STRING?: Maybe<Scalars['String']>;
  INT?: Maybe<Scalars['Int']>;
  FLOAT?: Maybe<Scalars['Float']>;
  BOOLEAN?: Maybe<Scalars['Boolean']>;
  DATE?: Maybe<Scalars['Date']>;
  TIME?: Maybe<Scalars['Time']>;
  DATETIME?: Maybe<Scalars['DateTime']>;
  JSON?: Maybe<Scalars['JSON']>;
  KIND?: Maybe<Scalars['ID']>;
  l_ID?: Maybe<Array<Maybe<Scalars['ID']>>>;
  l_STRING?: Maybe<Array<Maybe<Scalars['String']>>>;
  l_INT?: Maybe<Array<Maybe<Scalars['Int']>>>;
  l_FLOAT?: Maybe<Array<Maybe<Scalars['Float']>>>;
  l_BOOLEAN?: Maybe<Array<Maybe<Scalars['Boolean']>>>;
  l_DATE?: Maybe<Array<Maybe<Scalars['Date']>>>;
  l_TIME?: Maybe<Array<Maybe<Scalars['Time']>>>;
  l_DATETIME?: Maybe<Array<Maybe<Scalars['DateTime']>>>;
  l_JSON?: Maybe<Array<Maybe<Scalars['JSON']>>>;
  l_KIND?: Maybe<Array<Maybe<Scalars['ID']>>>;
};

/** File type - handles files within the UI */
export type File = EntityInterface & {
  __typename: 'File';
  id: Scalars['ID'];
  name: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  nameDescriptor?: Maybe<Scalars['String']>;
  serviceId: Scalars['ID'];
  /** The url to where the file data is stored */
  url: Scalars['String'];
  /** The url to the thumbnail for this file */
  thumbnailUrl?: Maybe<Scalars['String']>;
  /** The mime type of the file */
  mimeType?: Maybe<Scalars['String']>;
  /** The status of the file upload */
  status: Scalars['Int'];
  /** The size of the file in bytes. */
  size: Scalars['Int'];
  /** The progress of the file upload in bytes */
  progress?: Maybe<Scalars['Int']>;
};

/** Function type - represents a Function in a service */
export type Function = EntityInterface & {
  __typename: 'Function';
  id: Scalars['ID'];
  name: Scalars['String'];
  nameDescriptor: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  /** Information about who locked the Function. */
  lock?: Maybe<EntityLock>;
  /**
   * The type of function, for example a function from an external service, or a
   * function that is visually authored to be run by CKG.
   */
  functionType: FunctionType;
  /**
   * The signature of the Function.  This is used to represent both the arguemnts
   * and the output of the Function, as it will always start with a FunctionType.
   */
  signature: Scalars['TypeExpression'];
  /** The service that the Function lives inside of. */
  service: Service;
  /** Type Parameters are placeholders for types and are used as generics. */
  typeParameters: Array<Scalars['ID']>;
  /** How the function is run (like query or mutation) */
  graphqlFunctionType: GraphQLFunctionType;
  /** Defines if this is a pure or impure Function, or if its purity is unknown. */
  isPure?: Maybe<Scalars['Boolean']>;
  /**
   * The implementation representing what the Function does.  This is only used by
   * Functions on Logic services.
   */
  implementation?: Maybe<Implementation>;
  inputMask?: Maybe<Array<ArgumentFieldSelection>>;
};

export type FunctionResultRef = {
  __typename: 'FunctionResultRef';
  result?: Maybe<Scalars['Boolean']>;
};

/**
 * FunctionType enum - The different types of functions that a function can
 * represent.
 */
export const enum FunctionType {
  EXTERNAL = 'EXTERNAL',
  CKG = 'CKG'
}

/** Graph type - properties for all types of graphs (knowledge, function, etc) */
export type Graph = {
  __typename: 'Graph';
  /** ID of the graph */
  id: Scalars['ID'];
  offset: Position;
  zoom: Scalars['Float'];
  /** Nodes that make up the graph. */
  nodes: Array<Node>;
  /** Connections between nodes on the graph. */
  connections: Array<Connection>;
};

/** FunctionType enum - the operation type for a Function (like query or mutation) */
export const enum GraphQLFunctionType {
  QUERY = 'QUERY',
  MUTATION = 'MUTATION',
  SUBSCRIPTION = 'SUBSCRIPTION',
  NONE = 'NONE'
}

/**
 * GraphRef union - info for one end of a connection between two items within the
 * graph.
 */
export type GraphRef =
  | ArgumentRef
  | OperationArgumentRef
  | FunctionResultRef
  | OperationResultRef
  | OutputArgumentRef;

export type GraphRefInput = {
  graphRefInputType: GraphRefInputType;
  argument?: Maybe<Scalars['ID']>;
  operationArgument?: Maybe<OperationArgumentRefInput>;
  operationResult?: Maybe<Scalars['ID']>;
  outputArgument?: Maybe<OutputArgumentRefInput>;
};

export const enum GraphRefInputType {
  ARGUMENT = 'ARGUMENT',
  OPERATION_ARGUMENT = 'OPERATION_ARGUMENT',
  FUNCTION_RESULT = 'FUNCTION_RESULT',
  OPERATION_RESULT = 'OPERATION_RESULT',
  OUTPUT_ARGUMENT_REF = 'OUTPUT_ARGUMENT_REF'
}

export type Image = {
  __typename: 'Image';
  detectedFaces?: Maybe<Array<Maybe<DetectedFace>>>;
  recognizedFaces?: Maybe<Array<Maybe<RecognizedFace>>>;
  people?: Maybe<Array<Maybe<Person>>>;
  id: Scalars['ID'];
  name: Scalars['String'];
  url?: Maybe<Scalars['String']>;
};

/** The union that defines the */
export type Implementation = Graph;

/**
 * ImplementationTypeInput enum - Defines what type of implementation is being
 * created or updated during a function create or update event.
 */
export const enum ImplementationTypeInput {
  FUNCTION_GRAPH = 'FUNCTION_GRAPH'
}

/** Info type - basic information about the service. */
export type Info = {
  __typename: 'Info';
  /** ID of the service */
  id: Scalars['ID'];
  /** Name of the service */
  name: Scalars['String'];
  /** Description of the service */
  description?: Maybe<Scalars['String']>;
};

export type Instance = {
  __typename: 'Instance';
  id: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
  kindId: Scalars['ID'];
  kind?: Maybe<Kind>;
  fieldIds?: Maybe<Array<Maybe<Scalars['ID']>>>;
  fieldValues?: Maybe<Array<Maybe<FieldValue>>>;
  linksFrom?: Maybe<Array<Maybe<Link>>>;
  linksTo?: Maybe<Array<Maybe<Link>>>;
  linkedKindsTo: Array<LinkedKind>;
  linkedKindsFrom: Array<LinkedKind>;
  linkedInstancesTo: Array<LinkedInstance>;
  linkedInstancesFrom: Array<LinkedInstance>;
};

export type InstancelinkedKindsToArgs = {
  relationId: Maybe<Scalars['ID']>;
};

export type InstancelinkedKindsFromArgs = {
  relationId: Maybe<Scalars['ID']>;
};

export type InstancelinkedInstancesToArgs = {
  relationId: Maybe<Scalars['ID']>;
};

export type InstancelinkedInstancesFromArgs = {
  relationId: Maybe<Scalars['ID']>;
};

export type InstanceIdsByKind = {
  kindId: Scalars['ID'];
  instanceIds: Array<Scalars['ID']>;
};

export type InstanceRef = {
  __typename: 'InstanceRef';
  id: Scalars['ID'];
  kindId?: Maybe<Scalars['ID']>;
  kindName?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  url?: Maybe<Scalars['String']>;
  kind?: Maybe<Kind>;
  instance?: Maybe<Instance>;
  innerKind?: Maybe<Kind>;
  innerFunction?: Maybe<Function>;
};

export type InstanceRefInput = {
  id?: Maybe<Scalars['ID']>;
  name?: Maybe<Scalars['String']>;
  kindId?: Maybe<Scalars['ID']>;
  kindName?: Maybe<Scalars['String']>;
  url?: Maybe<Scalars['String']>;
  instance?: Maybe<Scalars['ID']>;
};

export type InstanceSet = {
  __typename: 'InstanceSet';
  kindId: Scalars['ID'];
  kind: Kind;
  token?: Maybe<Scalars['String']>;
  fieldIds?: Maybe<Array<Maybe<Scalars['ID']>>>;
  records?: Maybe<Array<Maybe<Array<Maybe<FieldValue>>>>>;
};

export type Kind = {
  __typename: 'Kind';
  id: Scalars['ID'];
  name: Scalars['String'];
  serviceId?: Maybe<Scalars['ID']>;
  description?: Maybe<Scalars['String']>;
  thumbnailUrl?: Maybe<Scalars['String']>;
  isPublic?: Maybe<Scalars['Boolean']>;
  isManaged?: Maybe<Scalars['Boolean']>;
  isSystem?: Maybe<Scalars['Boolean']>;
  schema?: Maybe<Array<Maybe<Field>>>;
  nameField?: Maybe<Scalars['ID']>;
  isGenerated: Scalars['Boolean'];
  relationsFrom?: Maybe<Array<Maybe<Relation>>>;
  relationsTo?: Maybe<Array<Maybe<Relation>>>;
  linksFrom?: Maybe<Array<Maybe<Link>>>;
  linksTo?: Maybe<Array<Maybe<Link>>>;
  service?: Maybe<Service>;
  linkedKindsTo: Array<LinkedKind>;
  linkedKindsFrom: Array<LinkedKind>;
  linkedInstancesTo: Array<LinkedInstance>;
  linkedInstancesFrom: Array<LinkedInstance>;
  isDeleted: Scalars['Boolean'];
};

export type KindschemaArgs = {
  includeDeleted?: Maybe<Scalars['Boolean']>;
  fieldIds: Maybe<Array<Scalars['ID']>>;
  fieldNames: Maybe<Array<Scalars['String']>>;
  fieldKinds: Maybe<Array<Scalars['ID']>>;
};

export type KindlinkedKindsToArgs = {
  relationId: Maybe<Scalars['ID']>;
};

export type KindlinkedKindsFromArgs = {
  relationId: Maybe<Scalars['ID']>;
};

export type KindlinkedInstancesToArgs = {
  relationId: Maybe<Scalars['ID']>;
};

export type KindlinkedInstancesFromArgs = {
  relationId: Maybe<Scalars['ID']>;
};

export type KindQueryInput = {
  kindId?: Maybe<Scalars['ID']>;
  kindName?: Maybe<Scalars['String']>;
  alias?: Maybe<Scalars['String']>;
  projection?: Maybe<Array<Maybe<FieldProjectionInput>>>;
  distinct?: Maybe<Scalars['Boolean']>;
  fieldFilters?: Maybe<Array<Maybe<FieldFilterInput>>>;
  and?: Maybe<Array<Maybe<KindQueryInput>>>;
  or?: Maybe<Array<Maybe<KindQueryInput>>>;
  fromFieldId?: Maybe<Scalars['ID']>;
  fromFieldName?: Maybe<Scalars['String']>;
  toFieldId?: Maybe<Scalars['ID']>;
  toFieldName?: Maybe<Scalars['String']>;
  take?: Maybe<Scalars['Int']>;
  drop?: Maybe<Scalars['Int']>;
  token?: Maybe<Scalars['String']>;
};

export type KnowledgeGraph = EntityInterface & {
  __typename: 'KnowledgeGraph';
  id: Scalars['ID'];
  name: Scalars['String'];
  nameDescriptor?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  /** Information about who locked the Knowledge Graph. */
  lock?: Maybe<EntityLock>;
  /** The workspace that the knowledge graph is a view over */
  workspace?: Maybe<Workspace>;
  /** The graph representing the KnowledgeGraph. */
  graph: Graph;
};

export type Link = {
  __typename: 'Link';
  id: Scalars['ID'];
  relation: Relation;
  fromKind?: Maybe<Kind>;
  toKind?: Maybe<Kind>;
  name?: Maybe<Scalars['String']>;
  weight?: Maybe<Scalars['Float']>;
  fromField?: Maybe<Field>;
  fromInstance?: Maybe<Instance>;
  fromOffset?: Maybe<Scalars['String']>;
  fromSpan?: Maybe<Scalars['String']>;
  toField?: Maybe<Field>;
  toInstance?: Maybe<Instance>;
  toOffset?: Maybe<Scalars['String']>;
  toSpan?: Maybe<Scalars['String']>;
};

export type LinkedInstance = {
  __typename: 'LinkedInstance';
  relation: Relation;
  kind?: Maybe<Kind>;
  instance?: Maybe<Instance>;
};

export type LinkedKind = {
  __typename: 'LinkedKind';
  relation: Relation;
  kind?: Maybe<Kind>;
  field?: Maybe<Field>;
};

/** LogicService type - Based on the one from Catalog */
export type LogicService = Service & {
  __typename: 'LogicService';
  id: Scalars['ID'];
  name: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  location: ServiceLocation;
  thumbnailUrl?: Maybe<Scalars['String']>;
  tags: Array<Scalars['String']>;
  version?: Maybe<Scalars['Int']>;
  graphqlSchema: Scalars['String'];
  functions: Array<Function>;
  types: Array<Type>;
};

/** ModelService type - Based on the one from Catalog */
export type ModelService = Service & {
  __typename: 'ModelService';
  id: Scalars['ID'];
  name: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  location: ServiceLocation;
  thumbnailUrl?: Maybe<Scalars['String']>;
  tags: Array<Scalars['String']>;
  version?: Maybe<Scalars['Int']>;
  graphqlSchema: Scalars['String'];
  functions: Array<Function>;
  types: Array<Type>;
};

export type ModWorkspacesOutput = {
  __typename: 'ModWorkspacesOutput';
  newWorkspaces: Array<Workspace>;
  newTypes: Array<Type>;
  newFunctions: Array<Function>;
  newKnowledgeGraphs: Array<KnowledgeGraph>;
  newFiles: Array<File>;
  newAnnotations: Array<Annotation>;
  newGraphNodes: Array<Node>;
  updatedWorkspaces: Array<Workspace>;
  updatedTypes: Array<Type>;
  updatedFunctions: Array<Function>;
  updatedKnowledgeGraphs: Array<KnowledgeGraph>;
  updatedFiles: Array<File>;
  updatedAnnotations: Array<Annotation>;
  updatedGraphNodes: Array<Node>;
  deletedTypes: Array<Scalars['ID']>;
  deletedFunctions: Array<Scalars['ID']>;
  deletedKnowledgeGraphs: Array<Scalars['ID']>;
  deletedFiles: Array<Scalars['ID']>;
  deletedAnnotations: Array<Scalars['ID']>;
  deletedGraphNodes: Array<Scalars['ID']>;
  addedServices: Array<Service>;
  newServices: Array<Service>;
  updatedServices: Array<Service>;
  removedServices: Array<Scalars['ID']>;
};

export type Mutation = {
  __typename: 'Mutation';
  addBotAction: Scalars['ID'];
  addDetectedFaces: Scalars['Boolean'];
  addDocument?: Maybe<Scalars['ID']>;
  addDocuments?: Maybe<Array<Maybe<Scalars['ID']>>>;
  addEntities?: Maybe<Scalars['Boolean']>;
  addImage?: Maybe<Scalars['ID']>;
  addImages?: Maybe<Array<Maybe<Scalars['ID']>>>;
  addInstance?: Maybe<Scalars['ID']>;
  addInstanceSet?: Maybe<Array<Maybe<Scalars['ID']>>>;
  addKind?: Maybe<Scalars['ID']>;
  addKinds?: Maybe<Array<Maybe<Scalars['ID']>>>;
  addLink?: Maybe<Scalars['ID']>;
  addLinks?: Maybe<Array<Maybe<Scalars['ID']>>>;
  addRecognizedFaces: Scalars['Boolean'];
  addRelation?: Maybe<Scalars['ID']>;
  /** @deprecated Deprecated in favor of createWorkspacesFromSchema and updateWorkspacesFromSchema */
  addServiceSource: Scalars['ID'];
  /** Bootstrap portal's persistence service */
  bootstrap: Scalars['Boolean'];
  cloneWorkspaces: ModWorkspacesOutput;
  /** Creates the list of assistant services. */
  createAssistants?: Maybe<Array<Maybe<Service>>>;
  /** Creates the list of external graphql services. */
  createExternalGraphQLServices?: Maybe<Array<Maybe<Service>>>;
  /** Creates new File entites. */
  createFiles: Array<File>;
  /** Creates new users. */
  createUsers?: Maybe<Array<User>>;
  createWorkspaces: ModWorkspacesOutput;
  createWorkspacesFromSchema: ModWorkspacesOutput;
  deleteDocument?: Maybe<Document>;
  deleteDocuments?: Maybe<Array<Maybe<Document>>>;
  /**
   * Deletes the File entites, cleaning up references to it in Workspaces and
   * Knowledge Graphs.
   */
  deleteFiles: DeleteEntitiesOutput;
  deleteInstance?: Maybe<Scalars['ID']>;
  deleteInstanceSet?: Maybe<Array<Maybe<Scalars['ID']>>>;
  deleteKind: DeleteEntitiesOutput;
  deleteLinks?: Maybe<Array<Maybe<Link>>>;
  /** Deletes the services that match the provided IDs. */
  deleteServices?: Maybe<DeleteEntitiesOutput>;
  deleteWorkspaces: DeleteEntitiesOutput;
  entitySearchAction: BotAction;
  entitySearchPurgeTemporaries: Scalars['Boolean'];
  /**
   * Refreshes the known information about a service when it is connected to an
   * external source. This is useful for updating the platforms understanding of an
   * external graphql service.
   */
  refreshServices?: Maybe<Array<Service>>;
  /** Submit customer feedback */
  submitFeedback: Scalars['Boolean'];
  testServiceConnection?: Maybe<Scalars['String']>;
  /** Updates the list of assistant services. */
  updateAssistants?: Maybe<Array<Maybe<Service>>>;
  updateBotAction: Scalars['ID'];
  /** Updates the list of external graphql services. */
  updateExternalGraphQLServices?: Maybe<Array<Maybe<Service>>>;
  /** Updates the File entites. */
  updateFiles: Array<File>;
  updateInstance?: Maybe<Scalars['ID']>;
  updateKind?: Maybe<Kind>;
  updateKinds: Array<Kind>;
  /** Updates existing users. */
  updateUsers?: Maybe<Array<User>>;
  updateWorkspaces: ModWorkspacesOutput;
  updateWorkspacesFromSchema: ModWorkspacesOutput;
};

export type MutationaddBotActionArgs = {
  input: Maybe<AddBotActionInput>;
};

export type MutationaddDetectedFacesArgs = {
  input: Array<DetectedFaceInput>;
};

export type MutationaddDocumentArgs = {
  input: Maybe<AddDocumentInput>;
};

export type MutationaddDocumentsArgs = {
  input: Array<AddDocumentInput>;
};

export type MutationaddEntitiesArgs = {
  input: AddEntitiesInput;
};

export type MutationaddImageArgs = {
  input: AddImageInput;
};

export type MutationaddImagesArgs = {
  input: Array<AddImageInput>;
};

export type MutationaddInstanceArgs = {
  tenantId: Scalars['ID'];
  input: AddInstanceInput;
};

export type MutationaddInstanceSetArgs = {
  tenantId: Scalars['ID'];
  input: AddInstanceSetInput;
};

export type MutationaddKindArgs = {
  tenantId: Scalars['ID'];
  input: AddKindInput;
};

export type MutationaddKindsArgs = {
  input: Array<AddKindInput>;
};

export type MutationaddLinkArgs = {
  input: AddLinkInput;
};

export type MutationaddLinksArgs = {
  input: Array<Maybe<AddLinkInput>>;
};

export type MutationaddRecognizedFacesArgs = {
  input: Array<RecognizedFaceInput>;
};

export type MutationaddRelationArgs = {
  input: AddRelationInput;
};

export type MutationaddServiceSourceArgs = {
  input: AddServiceSourceInput;
};

export type MutationcloneWorkspacesArgs = {
  input: Array<CloneWorkspaceInput>;
};

export type MutationcreateAssistantsArgs = {
  input: Array<CreateAssistantInput>;
};

export type MutationcreateExternalGraphQLServicesArgs = {
  input: Array<CreateExternalGraphQLServiceInput>;
};

export type MutationcreateFilesArgs = {
  input: Array<CreateFileInput>;
};

export type MutationcreateUsersArgs = {
  input: Array<CreateUserInput>;
};

export type MutationcreateWorkspacesArgs = {
  input: Array<CreateWorkspaceInput>;
};

export type MutationcreateWorkspacesFromSchemaArgs = {
  input: Array<CreateWorkspaceFromSchemaInput>;
};

export type MutationdeleteDocumentArgs = {
  id: Scalars['ID'];
};

export type MutationdeleteDocumentsArgs = {
  ids: Array<Scalars['ID']>;
};

export type MutationdeleteFilesArgs = {
  ids: Array<Scalars['ID']>;
};

export type MutationdeleteInstanceArgs = {
  tenantId: Scalars['ID'];
  input: DeleteInstanceInput;
};

export type MutationdeleteInstanceSetArgs = {
  tenantId: Scalars['ID'];
  input: DeleteInstanceSetInput;
};

export type MutationdeleteKindArgs = {
  kindId: Scalars['ID'];
};

export type MutationdeleteLinksArgs = {
  ids: Array<Scalars['ID']>;
};

export type MutationdeleteServicesArgs = {
  services: Array<ServiceRefInput>;
};

export type MutationdeleteWorkspacesArgs = {
  workspaces: Array<WorkspaceRefInput>;
};

export type MutationentitySearchActionArgs = {
  input: EntitySearchInput;
  resultKey: Maybe<Scalars['String']>;
};

export type MutationentitySearchPurgeTemporariesArgs = {
  resultKey: Maybe<Scalars['String']>;
};

export type MutationrefreshServicesArgs = {
  services: Array<ServiceRefInput>;
  dryRun: Maybe<Scalars['Boolean']>;
};

export type MutationsubmitFeedbackArgs = {
  feedback: Scalars['String'];
  attachments: Array<AttachmentInput>;
};

export type MutationtestServiceConnectionArgs = {
  input: TestConnectionInput;
};

export type MutationupdateAssistantsArgs = {
  input: Array<UpdateAssistantInput>;
};

export type MutationupdateBotActionArgs = {
  input: Maybe<UpdateBotActionInput>;
};

export type MutationupdateExternalGraphQLServicesArgs = {
  input: Array<UpdateExternalGraphQLServiceInput>;
};

export type MutationupdateFilesArgs = {
  input: Array<UpdateFileInput>;
};

export type MutationupdateInstanceArgs = {
  tenantId: Scalars['ID'];
  input: UpdateInstanceInput;
};

export type MutationupdateKindArgs = {
  tenantId: Scalars['ID'];
  input: UpdateKindInput;
};

export type MutationupdateKindsArgs = {
  input: Array<UpdateKindInput>;
};

export type MutationupdateUsersArgs = {
  input: Array<UpdateUserInput>;
};

export type MutationupdateWorkspacesArgs = {
  input: Array<UpdateWorkspaceInput>;
};

export type MutationupdateWorkspacesFromSchemaArgs = {
  input: Array<UpdateWorkspaceFromSchemaInput>;
};

/**
 * Node type - properties for all types of graph nodes (function, type, projection,
 * construction, etc)
 */
export interface Node {
  id: Scalars['ID'];
  /** Human readable description of the Node. */
  description?: Maybe<Scalars['String']>;
  /**
   * Position of the node on the graph. Null indicates the need to layout the
   * position.
   */
  location?: Maybe<Position>;
  /** Indicates if the node is collapsed or expanded in the node display. */
  isCollapsed: Array<Scalars['String']>;
}

/** NodeType num - the different types of nodes used on the graphs. */
export const enum NodeType {
  ARGUMENT = 'ARGUMENT',
  ENTITY = 'ENTITY',
  OPERATION = 'OPERATION'
}

export type OperationArgumentRef = {
  __typename: 'OperationArgumentRef';
  operationId: Scalars['ID'];
  argumentName: Scalars['String'];
  argumentId: Scalars['ID'];
};

export type OperationArgumentRefInput = {
  operation: Scalars['ID'];
  argument: Scalars['ID'];
};

export type OperationNode = Node & {
  __typename: 'OperationNode';
  id: Scalars['ID'];
  description?: Maybe<Scalars['String']>;
  location?: Maybe<Position>;
  isCollapsed: Array<Scalars['String']>;
  /** The function wrapped by the operation node for use in a function graph */
  function: Function;
};

export type OperationResultRef = {
  __typename: 'OperationResultRef';
  operationId: Scalars['ID'];
};

export type OrderedList = {
  __typename: 'OrderedList';
  id: Scalars['ID'];
  type?: Maybe<Scalars['String']>;
  items?: Maybe<Array<Maybe<OrderedListItem>>>;
};

export type OrderedListItem = {
  __typename: 'OrderedListItem';
  id: Scalars['ID'];
  index?: Maybe<Scalars['Int']>;
  contents?: Maybe<Array<Maybe<Content>>>;
};

export type OutputArgumentRef = {
  __typename: 'OutputArgumentRef';
  operation: Scalars['ID'];
  fieldPath: Array<Scalars['ID']>;
  argument: Scalars['ID'];
};

export type OutputArgumentRefInput = {
  operation: Scalars['ID'];
  fieldPath: Array<Scalars['ID']>;
  argument: Scalars['ID'];
};

export type Page = {
  __typename: 'Page';
  id: Scalars['ID'];
  contents?: Maybe<Array<Maybe<Content>>>;
  number?: Maybe<Scalars['Int']>;
  header?: Maybe<Array<Maybe<Content>>>;
  footer?: Maybe<Array<Maybe<Content>>>;
};

export type Person = {
  __typename: 'Person';
  images?: Maybe<Array<Maybe<Image>>>;
  id: Scalars['ID'];
  name: Scalars['String'];
  givenName?: Maybe<Scalars['String']>;
  familyName?: Maybe<Scalars['String']>;
  dateOfBirth?: Maybe<Scalars['Date']>;
};

/** Position type - use to define location or offset on a graph */
export type Position = {
  __typename: 'Position';
  /** X coordinate. */
  x: Scalars['Float'];
  /** Y coordinate. */
  y: Scalars['Float'];
};

/** Position input - used to define location or offset on a graph */
export type PositionInput = {
  /** X coordinate. */
  x?: Maybe<Scalars['Float']>;
  /** Y coordinate. */
  y?: Maybe<Scalars['Float']>;
};

export type Query = {
  __typename: 'Query';
  /** Returns activities by ID */
  activities: Array<Activity>;
  /** Returns the feed of recent activities. */
  activityFeed: Array<Activity>;
  allInstances?: Maybe<InstanceSet>;
  allKinds?: Maybe<Array<Maybe<Kind>>>;
  allLinks?: Maybe<Array<Maybe<Link>>>;
  allReferencedInstances: Array<Instance>;
  allReferencedKinds: Array<Kind>;
  /**
   * Goes though the signature tree on the on passed in entities, and returns the
   * list of services referenced in that tree. This is inclusive, so the services
   * that the incoming entities belong to are also returned.
   *
   * Note: This query can get very slow when there are many services referenced
   * while it transverses the references to build the list.
   */
  allReferencedServices: Array<Service>;
  allRelations?: Maybe<Array<Maybe<Relation>>>;
  /** Load all of the services, limited only by the inputs. */
  allServices: Array<Service>;
  /** Returns all of the users in the system. */
  allUsers: Array<User>;
  botAction?: Maybe<BotAction>;
  botActions: Array<BotAction>;
  botActionsForServicesOnKind: Array<BotAction>;
  classification: Array<Link>;
  /** Platform version information. */
  componentVersions: Array<Scalars['String']>;
  document?: Maybe<Document>;
  documents?: Maybe<Array<Maybe<Document>>>;
  entitySearch?: Maybe<Array<EntitySearchResult>>;
  entitySearchResult: EntitySearchActionResult;
  /**
   * Returns a group of File entities with the given group of ids.  Allows for a
   * partial update of the File based on the fields defined in the input.
   */
  files: Array<File>;
  image?: Maybe<Image>;
  images?: Maybe<Array<Maybe<Image>>>;
  /** Returns basic information about the service */
  info: Info;
  instance?: Maybe<Instance>;
  instanceRef?: Maybe<InstanceRef>;
  instances?: Maybe<InstanceSet>;
  instancesByRef?: Maybe<Array<Maybe<Instance>>>;
  kind?: Maybe<Kind>;
  /** Query KindDB for Kinds using a Kind Query. Only Kinds are returned. Instances are not supported. */
  kindDBKindQuery?: Maybe<Array<Maybe<Kind>>>;
  kindDBQuery?: Maybe<InstanceSet>;
  kinds?: Maybe<Array<Maybe<Kind>>>;
  link?: Maybe<Link>;
  links?: Maybe<Array<Maybe<Link>>>;
  populateInstanceRef?: Maybe<InstanceRef>;
  relation?: Maybe<Relation>;
  relations?: Maybe<Array<Maybe<Relation>>>;
  search?: Maybe<SearchResult>;
  /** Load a list of services based on the provided IDs. */
  services: Array<Maybe<Service>>;
  /** Returns a list of users based on the provided IDs. */
  users: Array<User>;
  /** Returns a list of users by email address. */
  usersByEmail: Array<User>;
  workspaces: Array<Workspace>;
  workspacesFiltered: Array<Workspace>;
};

export type QueryactivitiesArgs = {
  ids: Array<Scalars['ID']>;
};

export type QueryallInstancesArgs = {
  tenantId: Scalars['ID'];
  kindId: Maybe<Scalars['ID']>;
  kindName: Maybe<Scalars['String']>;
  fieldIds: Maybe<Array<Scalars['ID']>>;
  take: Maybe<Scalars['Int']>;
  drop: Maybe<Scalars['Int']>;
  token: Maybe<Scalars['String']>;
};

export type QueryallKindsArgs = {
  tenantId: Scalars['ID'];
  serviceId: Maybe<Scalars['String']>;
  take: Maybe<Scalars['Int']>;
  includeSvc: Maybe<Scalars['Boolean']>;
};

export type QueryallLinksArgs = {
  tenantId: Scalars['ID'];
  relationId: Maybe<Scalars['ID']>;
};

export type QueryallReferencedInstancesArgs = {
  tenantId: Scalars['ID'];
  instanceIdsByKind: Array<InstanceIdsByKind>;
  maxDepth: Maybe<Scalars['Int']>;
  instancesToSkipByKind: Maybe<Array<InstanceIdsByKind>>;
};

export type QueryallReferencedKindsArgs = {
  tenantId: Scalars['ID'];
  ids: Array<Scalars['ID']>;
  maxDepth: Maybe<Scalars['Int']>;
  idsToSkip: Maybe<Array<Scalars['ID']>>;
};

export type QueryallReferencedServicesArgs = {
  input: AllReferencedServicesInput;
};

export type QueryallRelationsArgs = {
  tenantId: Scalars['ID'];
};

export type QueryallServicesArgs = {
  take?: Scalars['Int'];
  drop?: Scalars['Int'];
};

export type QueryallUsersArgs = {
  take: Maybe<Scalars['Int']>;
  offset: Maybe<Scalars['Int']>;
};

export type QuerybotActionArgs = {
  id: Scalars['ID'];
};

export type QuerybotActionsArgs = {
  ids: Array<Scalars['ID']>;
};

export type QuerybotActionsForServicesOnKindArgs = {
  serviceIds: Array<Scalars['ID']>;
  kindId: Scalars['ID'];
  take: Maybe<Scalars['Int']>;
  token: Maybe<Scalars['String']>;
};

export type QueryclassificationArgs = {
  id: Scalars['ID'];
};

export type QuerydocumentArgs = {
  id: Scalars['ID'];
};

export type QuerydocumentsArgs = {
  ids: Array<Scalars['ID']>;
};

export type QueryentitySearchArgs = {
  input: EntitySearchInput;
};

export type QueryentitySearchResultArgs = {
  resultKey: Scalars['String'];
  token: Maybe<Scalars['String']>;
  take: Maybe<Scalars['Int']>;
};

export type QueryfilesArgs = {
  ids: Array<Scalars['ID']>;
};

export type QueryimageArgs = {
  id: Scalars['ID'];
};

export type QueryimagesArgs = {
  ids: Array<Scalars['ID']>;
};

export type QueryinstanceArgs = {
  tenantId: Scalars['ID'];
  instanceRef: InstanceRefInput;
};

export type QueryinstanceRefArgs = {
  tenantId: Scalars['ID'];
  id: Scalars['ID'];
};

export type QueryinstancesArgs = {
  tenantId: Scalars['ID'];
  kindId: Maybe<Scalars['ID']>;
  kindName: Maybe<Scalars['String']>;
  ids: Array<Scalars['ID']>;
};

export type QueryinstancesByRefArgs = {
  tenantId: Scalars['ID'];
  instanceRefs: Array<InstanceRefInput>;
};

export type QuerykindArgs = {
  tenantId: Scalars['ID'];
  id: Maybe<Scalars['ID']>;
  name: Maybe<Scalars['String']>;
};

export type QuerykindDBKindQueryArgs = {
  kindQuery: KindQueryInput;
};

export type QuerykindDBQueryArgs = {
  kindQuery: KindQueryInput;
};

export type QuerykindsArgs = {
  tenantId: Scalars['ID'];
  ids: Array<Scalars['ID']>;
};

export type QuerylinkArgs = {
  tenantId: Scalars['ID'];
  id: Scalars['ID'];
};

export type QuerylinksArgs = {
  tenantId: Scalars['ID'];
  ids: Array<Maybe<Scalars['ID']>>;
};

export type QuerypopulateInstanceRefArgs = {
  tenantId: Scalars['ID'];
  instanceRef: InstanceRefInput;
};

export type QueryrelationArgs = {
  tenantId: Scalars['ID'];
  id: Scalars['ID'];
};

export type QueryrelationsArgs = {
  tenantId: Scalars['ID'];
  ids: Array<Maybe<Scalars['ID']>>;
};

export type QuerysearchArgs = {
  term: Scalars['String'];
  scopes: Array<SearchScope>;
  userId: Scalars['ID'];
};

export type QueryservicesArgs = {
  ids: Maybe<Array<Scalars['ID']>>;
};

export type QueryusersArgs = {
  ids: Array<Scalars['ID']>;
};

export type QueryusersByEmailArgs = {
  emails: Array<Scalars['String']>;
};

export type QueryworkspacesArgs = {
  ids: Array<Scalars['ID']>;
};

export type QueryworkspacesFilteredArgs = {
  input: WorkspaceFilterInput;
};

export type RecognizedFace = {
  __typename: 'RecognizedFace';
  id: Scalars['ID'];
  name: Scalars['String'];
  personId: Scalars['ID'];
  person: Person;
  detectedFaceId: Scalars['ID'];
  detectedFace?: Maybe<DetectedFace>;
  recognitionConfidence: Scalars['Float'];
};

export type RecognizedFaceInput = {
  id?: Maybe<Scalars['ID']>;
  name: Scalars['String'];
  personId: Scalars['ID'];
  detectedFaceId: Scalars['ID'];
  recognitionConfidence: Scalars['Float'];
};

export type Relation = {
  __typename: 'Relation';
  id: Scalars['ID'];
  name: Scalars['String'];
  inverseName: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  undirected?: Maybe<Scalars['Boolean']>;
  weight?: Maybe<Scalars['Float']>;
  links?: Maybe<Array<Maybe<Link>>>;
};

export type SearchResult = {
  __typename: 'SearchResult';
  kinds?: Maybe<Array<SearchResultItem>>;
  functions?: Maybe<Array<SearchResultItem>>;
  services?: Maybe<Array<SearchResultItem>>;
  workspaces?: Maybe<Array<SearchResultItem>>;
  assistants?: Maybe<Array<SearchResultItem>>;
};

export type SearchResultItem = {
  __typename: 'SearchResultItem';
  id: Scalars['ID'];
  name: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  service?: Maybe<ServiceInfo>;
};

export const enum SearchScope {
  Services = 'Services',
  Kinds = 'Kinds',
  Functions = 'Functions',
  Workspaces = 'Workspaces',
  Assistants = 'Assistants'
}

export type Section = {
  __typename: 'Section';
  id: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
  contents?: Maybe<Array<Maybe<Content>>>;
  subSections?: Maybe<Array<Maybe<Section>>>;
};

/** Service interface - Based on the one from Catalog */
export interface Service {
  id: Scalars['ID'];
  name: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  location: ServiceLocation;
  thumbnailUrl?: Maybe<Scalars['String']>;
  tags: Array<Scalars['String']>;
  version?: Maybe<Scalars['Int']>;
}

export type ServiceInfo = {
  __typename: 'ServiceInfo';
  id: Scalars['ID'];
  name: Scalars['String'];
};

export interface ServiceLocation {
  url: Scalars['String'];
}

export type ServiceRefInput = {
  id: Scalars['ID'];
  version: Scalars['Int'];
};

export type Subscription = {
  __typename: 'Subscription';
  botActionAdded: BotActionAddedEvent;
  botActionUpdated: BotActionUpdatedEvent;
  linkAdded: Link;
};

export type SubscriptionbotActionAddedArgs = {
  serviceId: Maybe<Scalars['ID']>;
  kindId: Maybe<Scalars['ID']>;
  botId: Maybe<Scalars['ID']>;
};

export type SubscriptionbotActionUpdatedArgs = {
  serviceIds: Maybe<Array<Scalars['ID']>>;
  kindIds: Maybe<Array<Scalars['ID']>>;
  botIds: Maybe<Array<Scalars['ID']>>;
  botActionIds: Maybe<Array<Scalars['ID']>>;
};

export type SubscriptionlinkAddedArgs = {
  kindIds: Maybe<Array<Scalars['ID']>>;
  relationIds: Maybe<Array<Scalars['ID']>>;
  instanceIds: Maybe<Array<Scalars['ID']>>;
  fieldIds: Maybe<Array<Scalars['ID']>>;
};

export type Table = {
  __typename: 'Table';
  id: Scalars['ID'];
  headers?: Maybe<Array<Maybe<Content>>>;
  rows?: Maybe<Array<Maybe<Content>>>;
};

export type TestConnectionInput = {
  id?: Maybe<Scalars['ID']>;
  url?: Maybe<Scalars['String']>;
};

/** Theme enum - lets the user change between different themes */
export const enum Theme {
  DARK = 'DARK',
  LIGHT = 'LIGHT'
}

export type Type = EntityInterface & {
  __typename: 'Type';
  id: Scalars['ID'];
  name: Scalars['String'];
  nameDescriptor?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  signature: Scalars['TypeExpression'];
  isManaged: Scalars['Boolean'];
  service: Service;
};

export type UnorderedList = {
  __typename: 'UnorderedList';
  id: Scalars['ID'];
  type?: Maybe<Scalars['String']>;
  items?: Maybe<Array<Maybe<UnorderedListItem>>>;
};

export type UnorderedListItem = {
  __typename: 'UnorderedListItem';
  id: Scalars['ID'];
  contents?: Maybe<Array<Maybe<Content>>>;
};

/**
 * UpdateAnnotation input - used to update existing annotations.  Allows
 * for a partial update of the annotation based on the fields defined in the
 * input.
 */
export type UpdateAnnotationInput = {
  id: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
};

/**
 * UpdateAssistantInput input - Based on the one from Catalog.  Allows for a
 * partial update of the Assistant based on the fields defined in the input.
 */
export type UpdateAssistantInput = {
  id: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  endpointUrl?: Maybe<Scalars['String']>;
  isSystem?: Maybe<Scalars['Boolean']>;
  isReadOnly?: Maybe<Scalars['Boolean']>;
  tags?: Maybe<Array<Scalars['String']>>;
  thumbnailUrl?: Maybe<Scalars['String']>;
  version: Scalars['Int'];
};

export type UpdateBotActionInput = {
  id: Scalars['ID'];
  status: BotActionStatus;
  progress?: Maybe<Scalars['Float']>;
  error?: Maybe<Scalars['JSON']>;
};

/** UpdateEntity input - A generic input for updating an entity. */
export type UpdateEntityInput = {
  entityType: EntityType;
  knowledgeGraph?: Maybe<UpdateKnowledgeGraphInput>;
  type?: Maybe<UpdateTypeInput>;
  function?: Maybe<UpdateFunctionInput>;
  file?: Maybe<UpdateFileInput>;
  annotation?: Maybe<UpdateAnnotationInput>;
};

/**
 * UpdateExternalGraphQLServiceInput input - Based on the one from Catalog.  Allows
 * for a partial update of the Service based on the fields defined in the input.
 */
export type UpdateExternalGraphQLServiceInput = {
  id: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  endpointUrl?: Maybe<Scalars['String']>;
  isSystem?: Maybe<Scalars['Boolean']>;
  isReadOnly?: Maybe<Scalars['Boolean']>;
  tags?: Maybe<Array<Scalars['String']>>;
  thumbnailUrl?: Maybe<Scalars['String']>;
  version: Scalars['Int'];
};

/**
 * UpdateFile input - used to update existing files. Only the fields with
 * information added to them in the input are updated.
 */
export type UpdateFileInput = {
  id: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  serviceId?: Maybe<Scalars['String']>;
  url?: Maybe<Scalars['String']>;
  thumbnailUrl?: Maybe<Scalars['String']>;
  mimeType?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['Int']>;
  progress?: Maybe<Scalars['Int']>;
  status?: Maybe<Scalars['Int']>;
};

/**
 * UpdateFunction input - info needed to update a Function (not its graph). Allows
 * for a partial update of the Function based on the fields defined in the input.
 */
export type UpdateFunctionInput = {
  id: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  signature?: Maybe<Scalars['TypeExpression']>;
  isPure?: Maybe<Scalars['Boolean']>;
  graphqlFunctionType?: Maybe<GraphQLFunctionType>;
  lock?: Maybe<EntityLockInput>;
  implementation?: Maybe<ImplementationTypeInput>;
  /**
   * Allows for updating the implementation for CKG Functions at the same time as
   * the Function.
   */
  graphImplementation?: Maybe<UpdateGraphInput>;
  inputMask?: Maybe<Array<ArgumentFieldSelectionInput>>;
};

/**
 * UpdateGraph input - allows for updating the graph (move, zoom, etc) as well add
 * creating/removing nodes and connections in a single mutation.  Allows for a
 * partial update of the Graph based on the fields defined in the input.
 */
export type UpdateGraphInput = {
  offset?: Maybe<PositionInput>;
  zoom?: Maybe<Scalars['Float']>;
  createNodes?: Maybe<Array<CreateNodeInput>>;
  updateNodes?: Maybe<Array<UpdateNodeInput>>;
  deleteNodes?: Maybe<Array<Scalars['ID']>>;
  createConnections?: Maybe<Array<CreateConnectionInput>>;
  deleteConnections?: Maybe<Array<Scalars['ID']>>;
};

export type UpdateInstanceInput = {
  id: Scalars['ID'];
  kindId: Scalars['ID'];
  fieldIds: Array<Maybe<Scalars['ID']>>;
  fieldValues: Array<Maybe<FieldValueInput>>;
};

export type UpdateKindInput = {
  id: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  serviceId?: Maybe<Scalars['ID']>;
  thumbnailUrl?: Maybe<Scalars['String']>;
  isPublic?: Maybe<Scalars['Boolean']>;
  nameField?: Maybe<Scalars['ID']>;
  isManaged?: Maybe<Scalars['Boolean']>;
  isSystem?: Maybe<Scalars['Boolean']>;
  schema?: Maybe<Array<FieldInput>>;
};

/**
 * UpdateKnowledgeGraph input - used to update existing knowledge graphs.  Allows
 * for a partial update of the Knowledge Graph based on the fields defined in the
 * input.
 */
export type UpdateKnowledgeGraphInput = {
  id: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  lock?: Maybe<EntityLockInput>;
  graph?: Maybe<UpdateGraphInput>;
};

/**
 * UpdateNode input - info needed to move position or expand/collapse a node.
 * Allows for a partial update of the Node based on the fields defined in the
 * input.
 */
export type UpdateNodeInput = {
  id: Scalars['ID'];
  location?: Maybe<PositionInput>;
  isCollapsed?: Maybe<Array<Scalars['String']>>;
  description?: Maybe<Scalars['String']>;
  /** The type of node being created */
  type: NodeType;
};

/**
 * UpdateType input - Used to update the information about a type.  Allows for a
 * partial update of the Type based on the fields defined in the input.
 */
export type UpdateTypeInput = {
  /**
   * The current ID of the Type, but this can change during the process of updating
   * the
   */
  id: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  signature?: Maybe<Scalars['TypeExpression']>;
  isManaged?: Maybe<Scalars['Boolean']>;
};

/**
 * UpdateUser input - used to update an existing User.  Allows for a partial
 * update of the User based on the fields defined in the input.
 */
export type UpdateUserInput = {
  id: Scalars['ID'];
  /** Sets the current theme for the user. */
  theme?: Maybe<Theme>;
  /** Adds entries to the users recent items list. */
  addRecentItems?: Maybe<Array<Scalars['EntityIdentifier']>>;
  /** Deletes entries from the users recent items list. */
  deleteRecentItems?: Maybe<Array<Scalars['EntityIdentifier']>>;
  /** Adds entries to the users favorite items list. */
  addFavoriteItems?: Maybe<Array<Scalars['EntityIdentifier']>>;
  /** Deletes entries from the users favorite items list. */
  deleteFavoriteItems?: Maybe<Array<Scalars['EntityIdentifier']>>;
  /** Adds entries to the users open workpsaces list. */
  addOpenWorkspaces?: Maybe<Array<Scalars['ID']>>;
  /** Deletes entries from the users open workspaces list. */
  deleteOpenWorkspaces?: Maybe<Array<Scalars['ID']>>;
};

export type UpdateWorkspaceFromSchemaInput = {
  id: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  thumbnailUrl?: Maybe<Scalars['String']>;
  tags?: Maybe<Array<Scalars['String']>>;
  isPublic?: Maybe<Scalars['Boolean']>;
  isTemplate?: Maybe<Scalars['Boolean']>;
  version: Scalars['Int'];
  schema: Scalars['String'];
};

/**
 * UpdateWorkspace input - used to update existing workspaces.  Allows for a
 * partial update of the Workspace based on the fields defined in the input.
 *
 * Operations happen in this order: create, clone, add, update, remove, delete.
 * Order within each input list matters. This will enable creating multiple things
 * in one call to the backend. For example, if server writes were delayed in the UI
 * for performance reasons, you could create several types and a function that
 * uses them... and update the names of those types and functions in a single
 * request.
 */
export type UpdateWorkspaceInput = {
  id: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  thumbnailUrl?: Maybe<Scalars['String']>;
  tags?: Maybe<Array<Scalars['String']>>;
  version: Scalars['Int'];
  isPublic?: Maybe<Scalars['Boolean']>;
  isTemplate?: Maybe<Scalars['Boolean']>;
  lock?: Maybe<EntityLockInput>;
  /** Create new entities: knowledgeGraphs, types, functions, files. */
  createEntities?: Maybe<Array<CreateEntityInput>>;
  /** Clone existing entities: types, functions. */
  cloneEntities?: Maybe<Array<CloneEntityInput>>;
  /** Updates the given entities: knowledgeGraphs, types, functions, files. */
  updateEntities?: Maybe<Array<UpdateEntityInput>>;
  /**
   * Moves the given entities from their current Workspace to this one.  Currently
   * only Types and Functions support being moved between Workspaces.
   */
  moveEntities?: Maybe<Array<Scalars['EntityIdentifier']>>;
  /**
   * Delete the entities from the Workspace: knowledgeGraphs, types, functions,
   * files, services.
   *
   * Entities created outside of this workspaces will be removed from this
   * workspace, but not deleted from the system.
   *
   * Entities created within this workspace should be deleted. If they are
   * referenced in other workspaces, the references should be removed as well
   * (inventory, graphs, schemas, etc). The backend has the responsibility to to
   * clean up in a proactive way. While the UI needs to be resilient to bad data,
   * it should not be the UI's responsibility to clean up.
   *
   * Deleting a knowledge graph does NOT delete the entities contained within it.
   * Deleting a function does NOT delete the entities contained within its graph.
   */
  deleteEntities?: Maybe<Array<Scalars['EntityIdentifier']>>;
  /** Add services to this workspace's inventory. */
  addServices?: Maybe<Array<Scalars['ID']>>;
  removeServices?: Maybe<Array<Scalars['ID']>>;
};

export type UrlLocation = ServiceLocation & {
  __typename: 'UrlLocation';
  url: Scalars['String'];
};

/** User type - stores information about a user */
export type User = {
  __typename: 'User';
  /** ID, usually the e-mail address of the user */
  id: Scalars['ID'];
  /** The users e-mail address */
  email: Scalars['String'];
  /** Name of the user */
  name: Scalars['String'];
  /** Given Name of the user */
  givenName?: Maybe<Scalars['String']>;
  /** Family Name of the user */
  familyName?: Maybe<Scalars['String']>;
  /** Url for the user's picture */
  picture?: Maybe<Scalars['String']>;
  /** User's preferred theme */
  theme: Theme;
  /** Date/time the user was added to the system */
  createdOn?: Maybe<Scalars['DateTime']>;
  /** List of the user's recently accessed items */
  recentItems: Array<EntityInterface>;
  /** List of the user's favorite items */
  favoriteItems: Array<EntityInterface>;
  /** List of the user's currently open workspaces */
  openWorkspaces: Array<Workspace>;
  /** List of the workspaces that the user owns */
  workspaces: Array<Workspace>;
};

/**
 * Workspace type - represents a workspace with its metadata, layout, various
 * entities and inventory.
 */
export type Workspace = EntityInterface & {
  __typename: 'Workspace';
  id: Scalars['ID'];
  name: Scalars['String'];
  nameDescriptor?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  location: ServiceLocation;
  thumbnailUrl?: Maybe<Scalars['String']>;
  tags: Array<Scalars['String']>;
  version?: Maybe<Scalars['Int']>;
  /** ID of the Service that is backing this Workspace. */
  serviceId: Scalars['ID'];
  /** The Service that is backing this Workspace. */
  service?: Maybe<LogicService>;
  /** ID of the Service that handles persistence for the managed Types. */
  persistenceServiceId: Scalars['ID'];
  /** The Service that handles persistence for the managed Types. */
  persistenceService?: Maybe<ModelService>;
  /** Workspace's owner which is the user that created the workspace. */
  owner: User;
  /** Indicates if the workspace is visible to other users */
  isPublic: Scalars['Boolean'];
  /** Indicates if the workspace is a template. */
  isTemplate: Scalars['Boolean'];
  /** Date/time when the workspace was created. */
  created: Scalars['DateTime'];
  /** Date/time when the workspace was last opened. */
  lastOpened: Scalars['DateTime'];
  /** The list of Knowledge Graphs in the Workspace. */
  knowledgeGraphs: Array<KnowledgeGraph>;
  /** The list of Functions that belong in the Workspace. */
  functions: Array<Function>;
  /** The list of Types that belong in the Workspace. */
  types: Array<Type>;
  /** The list of Services that the Workspace relies on. */
  services: Array<Service>;
  /** List of all files available in the workspace. */
  files: Array<File>;
  /** List of all annotations available in the workspace. */
  annotations: Array<Annotation>;
  /** Information about who locked the Workspace. */
  lock?: Maybe<EntityLock>;
};

/**
 * WorkspaceFilter input - search criteria for workspaces. If a property is null,
 * this will not filter on that criteria.
 */
export type WorkspaceFilterInput = {
  /** Filter workspaces by their ID. */
  ids?: Maybe<Array<Scalars['ID']>>;
  /** Filter workspaces by their name. */
  names?: Maybe<Array<Scalars['String']>>;
  /** Filter workspaces by their owner. */
  owners?: Maybe<Array<Scalars['ID']>>;
  /** Filter workspaces by their underlying logic service. */
  services?: Maybe<Array<Scalars['ID']>>;
  /** If true, return only public services. If false, return non-public services. */
  isPublic?: Maybe<Scalars['Boolean']>;
  /**
   * If true, return only template services. If false, return non-template
   * services.
   */
  isTemplate?: Maybe<Scalars['Boolean']>;
  /** The maximum number of services to return. */
  take?: Scalars['Int'];
  /**
   * The number of services to skip prior to returning the number of services
   * specified by take.
   */
  drop?: Scalars['Int'];
};

export type WorkspaceRefInput = {
  id: Scalars['ID'];
  version: Scalars['Int'];
};
